//
// Generated by Bluespec Compiler (build 26e119fb)
//
// On Wed Jun  9 16:13:41 IST 2021
//
//
// Ports:
// Name                         I/O  size props
// RDY_put_x                      O     1
// RDY_put_y                      O     1
// get_z                          O    32 reg
// RDY_get_z                      O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_x_x                        I    32
// put_y_y                        I    32
// EN_put_x                       I     1
// EN_put_y                       I     1
// EN_get_z                       I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMult(CLK,
	      RST_N,

	      put_x_x,
	      EN_put_x,
	      RDY_put_x,

	      put_y_y,
	      EN_put_y,
	      RDY_put_y,

	      EN_get_z,
	      get_z,
	      RDY_get_z);
  input  CLK;
  input  RST_N;

  // action method put_x
  input  [31 : 0] put_x_x;
  input  EN_put_x;
  output RDY_put_x;

  // action method put_y
  input  [31 : 0] put_y_y;
  input  EN_put_y;
  output RDY_put_y;

  // actionvalue method get_z
  input  EN_get_z;
  output [31 : 0] get_z;
  output RDY_get_z;

  // signals for module outputs
  wire [31 : 0] get_z;
  wire RDY_get_z, RDY_put_x, RDY_put_y;

  // register d
  reg [31 : 0] d;
  wire [31 : 0] d$D_IN;
  wire d$EN;

  // register got_x
  reg got_x;
  wire got_x$D_IN, got_x$EN;

  // register got_y
  reg got_y;
  wire got_y$D_IN, got_y$EN;

  // register product
  reg [31 : 0] product;
  wire [31 : 0] product$D_IN;
  wire product$EN;

  // register r
  reg [31 : 0] r;
  wire [31 : 0] r$D_IN;
  wire r$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_rl_compute;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_d$write_1__VAL_2,
		MUX_product$write_1__VAL_1,
		MUX_r$write_1__VAL_2;
  wire MUX_product$write_1__SEL_1;

  // remaining internal signals
  wire [30 : 0] r_BITS_31_TO_1__q1;

  // action method put_x
  assign RDY_put_x = !got_x ;

  // action method put_y
  assign RDY_put_y = !got_y ;

  // actionvalue method get_z
  assign get_z = product ;
  assign RDY_get_z = r == 32'd0 && got_x && got_y ;

  // rule RL_rl_compute
  assign WILL_FIRE_RL_rl_compute = got_x && got_y && r != 32'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_product$write_1__SEL_1 = WILL_FIRE_RL_rl_compute && r[0] ;
  assign MUX_d$write_1__VAL_2 = { d[30:0], 1'd0 } ;
  assign MUX_product$write_1__VAL_1 = product + d ;
  assign MUX_r$write_1__VAL_2 =
	     { r_BITS_31_TO_1__q1[30], r_BITS_31_TO_1__q1 } ;

  // register d
  assign d$D_IN = EN_put_x ? put_x_x : MUX_d$write_1__VAL_2 ;
  assign d$EN = EN_put_x || WILL_FIRE_RL_rl_compute ;

  // register got_x
  assign got_x$D_IN = !EN_get_z ;
  assign got_x$EN = EN_get_z || EN_put_x ;

  // register got_y
  assign got_y$D_IN = !EN_get_z ;
  assign got_y$EN = EN_get_z || EN_put_y ;

  // register product
  assign product$D_IN =
	     MUX_product$write_1__SEL_1 ? MUX_product$write_1__VAL_1 : 32'd0 ;
  assign product$EN = WILL_FIRE_RL_rl_compute && r[0] || EN_put_x ;

  // register r
  assign r$D_IN = EN_put_y ? put_y_y : MUX_r$write_1__VAL_2 ;
  assign r$EN = EN_put_y || WILL_FIRE_RL_rl_compute ;

  // remaining internal signals
  assign r_BITS_31_TO_1__q1 = r[31:1] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        d <= `BSV_ASSIGNMENT_DELAY 32'd0;
	got_x <= `BSV_ASSIGNMENT_DELAY 1'd0;
	got_y <= `BSV_ASSIGNMENT_DELAY 1'd0;
	product <= `BSV_ASSIGNMENT_DELAY 32'd0;
	r <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (d$EN) d <= `BSV_ASSIGNMENT_DELAY d$D_IN;
	if (got_x$EN) got_x <= `BSV_ASSIGNMENT_DELAY got_x$D_IN;
	if (got_y$EN) got_y <= `BSV_ASSIGNMENT_DELAY got_y$D_IN;
	if (product$EN) product <= `BSV_ASSIGNMENT_DELAY product$D_IN;
	if (r$EN) r <= `BSV_ASSIGNMENT_DELAY r$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    d = 32'hAAAAAAAA;
    got_x = 1'h0;
    got_y = 1'h0;
    product = 32'hAAAAAAAA;
    r = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMult

