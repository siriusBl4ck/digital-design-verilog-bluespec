//
// Generated by Bluespec Compiler (build 26e119fb)
//
// On Mon Aug 30 02:36:32 IST 2021
//
//
// Ports:
// Name                         I/O  size props
// RDY_put_command                O     1 reg
// get_result                     O    32 reg
// RDY_get_result                 O     1 reg
// checkErr                       O    32 reg
// RDY_checkErr                   O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_command_x                  I    32 reg
// put_command_y                  I    32 reg
// put_command_opnum              I    32 reg
// EN_put_command                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAlu(CLK,
	     RST_N,

	     put_command_x,
	     put_command_y,
	     put_command_opnum,
	     EN_put_command,
	     RDY_put_command,

	     get_result,
	     RDY_get_result,

	     checkErr,
	     RDY_checkErr);
  input  CLK;
  input  RST_N;

  // action method put_command
  input  [31 : 0] put_command_x;
  input  [31 : 0] put_command_y;
  input  [31 : 0] put_command_opnum;
  input  EN_put_command;
  output RDY_put_command;

  // value method get_result
  output [31 : 0] get_result;
  output RDY_get_result;

  // value method checkErr
  output [31 : 0] checkErr;
  output RDY_checkErr;

  // signals for module outputs
  wire [31 : 0] checkErr, get_result;
  wire RDY_checkErr, RDY_get_result, RDY_put_command;

  // register a
  reg [31 : 0] a;
  wire [31 : 0] a$D_IN;
  wire a$EN;

  // register b
  reg [31 : 0] b;
  wire [31 : 0] b$D_IN;
  wire b$EN;

  // register err
  reg [31 : 0] err;
  wire [31 : 0] err$D_IN;
  wire err$EN;

  // register opcode
  reg [31 : 0] opcode;
  wire [31 : 0] opcode$D_IN;
  wire opcode$EN;

  // register rdy
  reg rdy;
  wire rdy$D_IN, rdy$EN;

  // register res
  reg [31 : 0] res;
  reg [31 : 0] res$D_IN;
  wire res$EN;

  // remaining internal signals
  wire [63 : 0] a_5_MUL_b___d18;
  wire [31 : 0] IF_a_5_BIT_31_0_AND_NOT_b_BIT_31_1_2_3_OR_NOT__ETC___d33,
		IF_a_5_BIT_31_0_THEN_NEG_a_5_7_ELSE_a_5_8_QUOT_ETC___d31,
		x__h502,
		x__h522;

  // action method put_command
  assign RDY_put_command = rdy ;

  // value method get_result
  assign get_result = res ;
  assign RDY_get_result = rdy ;

  // value method checkErr
  assign checkErr = err ;
  assign RDY_checkErr = rdy ;

  // register a
  assign a$D_IN = put_command_x ;
  assign a$EN = EN_put_command ;

  // register b
  assign b$D_IN = put_command_y ;
  assign b$EN = EN_put_command ;

  // register err
  assign err$D_IN = 32'd1 ;
  assign err$EN =
	     !rdy && opcode != 32'd1 && opcode != 32'd2 && opcode != 32'd3 &&
	     (opcode != 32'd4 || b == 32'd0) ;

  // register opcode
  assign opcode$D_IN = put_command_opnum ;
  assign opcode$EN = EN_put_command ;

  // register rdy
  assign rdy$D_IN = !EN_put_command ;
  assign rdy$EN = EN_put_command || !rdy ;

  // register res
  always@(opcode or
	  IF_a_5_BIT_31_0_AND_NOT_b_BIT_31_1_2_3_OR_NOT__ETC___d33 or
	  a or b or a_5_MUL_b___d18)
  begin
    case (opcode)
      32'd1: res$D_IN = a + b;
      32'd2: res$D_IN = a - b;
      32'd3: res$D_IN = a_5_MUL_b___d18[31:0];
      default: res$D_IN =
		   IF_a_5_BIT_31_0_AND_NOT_b_BIT_31_1_2_3_OR_NOT__ETC___d33;
    endcase
  end
  assign res$EN =
	     !rdy &&
	     (opcode == 32'd1 || opcode == 32'd2 || opcode == 32'd3 ||
	      opcode == 32'd4 && b != 32'd0) ;

  // remaining internal signals
  assign IF_a_5_BIT_31_0_AND_NOT_b_BIT_31_1_2_3_OR_NOT__ETC___d33 =
	     (a[31] && !b[31] || !a[31] && b[31]) ?
	       -IF_a_5_BIT_31_0_THEN_NEG_a_5_7_ELSE_a_5_8_QUOT_ETC___d31 :
	       IF_a_5_BIT_31_0_THEN_NEG_a_5_7_ELSE_a_5_8_QUOT_ETC___d31 ;
  assign IF_a_5_BIT_31_0_THEN_NEG_a_5_7_ELSE_a_5_8_QUOT_ETC___d31 =
	     x__h502 / x__h522 ;
  assign a_5_MUL_b___d18 = a * b ;
  assign x__h502 = a[31] ? -a : a ;
  assign x__h522 = b[31] ? -b : b ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        a <= `BSV_ASSIGNMENT_DELAY 32'd0;
	b <= `BSV_ASSIGNMENT_DELAY 32'd0;
	err <= `BSV_ASSIGNMENT_DELAY 32'd0;
	opcode <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rdy <= `BSV_ASSIGNMENT_DELAY 1'd1;
	res <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (a$EN) a <= `BSV_ASSIGNMENT_DELAY a$D_IN;
	if (b$EN) b <= `BSV_ASSIGNMENT_DELAY b$D_IN;
	if (err$EN) err <= `BSV_ASSIGNMENT_DELAY err$D_IN;
	if (opcode$EN) opcode <= `BSV_ASSIGNMENT_DELAY opcode$D_IN;
	if (rdy$EN) rdy <= `BSV_ASSIGNMENT_DELAY rdy$D_IN;
	if (res$EN) res <= `BSV_ASSIGNMENT_DELAY res$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    a = 32'hAAAAAAAA;
    b = 32'hAAAAAAAA;
    err = 32'hAAAAAAAA;
    opcode = 32'hAAAAAAAA;
    rdy = 1'h0;
    res = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkAlu

